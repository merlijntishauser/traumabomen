export enum RelationshipType {
  BiologicalParent = "biological_parent",
  CoParent = "co_parent",
  StepParent = "step_parent",
  AdoptiveParent = "adoptive_parent",
  BiologicalSibling = "biological_sibling",
  StepSibling = "step_sibling",
  HalfSibling = "half_sibling",
  Partner = "partner",
  Friend = "friend",
}

export enum PartnerStatus {
  Together = "together",
  Married = "married",
  Separated = "separated",
  Divorced = "divorced",
}

export enum TraumaCategory {
  Loss = "loss",
  Abuse = "abuse",
  Addiction = "addiction",
  War = "war",
  Displacement = "displacement",
  Illness = "illness",
  Poverty = "poverty",
}

export interface RelationshipPeriod {
  start_year: number;
  end_year: number | null;
  status: PartnerStatus;
}

function stripAutoGeneratedDivorces(sorted: RelationshipPeriod[]): RelationshipPeriod[] {
  const marriedEndYears = new Set(
    sorted
      .filter((p) => p.status === PartnerStatus.Married && p.end_year != null)
      .map((p) => p.end_year!),
  );
  return sorted.filter(
    (p) => !(p.status === PartnerStatus.Divorced && marriedEndYears.has(p.start_year)),
  );
}

function computeEarliestDeath(partnerDeathYears?: {
  source?: number | null;
  target?: number | null;
}): number | null {
  const candidates: number[] = [];
  if (partnerDeathYears?.source) candidates.push(partnerDeathYears.source);
  if (partnerDeathYears?.target) candidates.push(partnerDeathYears.target);
  return candidates.length > 0 ? Math.min(...candidates) : null;
}

function computeDivorceEndYear(
  endYear: number,
  next: RelationshipPeriod | undefined,
  earliestDeath: number | null,
): number | null {
  const candidates: number[] = [];
  if (next) candidates.push(next.start_year);
  if (earliestDeath != null && earliestDeath >= endYear) candidates.push(earliestDeath);
  return candidates.length > 0 ? Math.min(...candidates) : null;
}

/**
 * Cap relationship periods at the earliest death year of either partner.
 *
 * Removes periods that start after death and caps end_year for periods
 * that extend beyond death. Periods already ending before death are unchanged.
 */
export function capPeriodsAtDeath(
  periods: RelationshipPeriod[],
  partnerDeathYears?: { source?: number | null; target?: number | null },
): RelationshipPeriod[] {
  const earliestDeath = computeEarliestDeath(partnerDeathYears);
  if (earliestDeath == null) return periods;

  return periods
    .filter((p) => p.start_year <= earliestDeath)
    .map((p) => {
      if (p.end_year == null || p.end_year > earliestDeath) {
        return { ...p, end_year: earliestDeath };
      }
      return p;
    });
}

/**
 * Auto-manage "divorced" periods after ended marriages.
 *
 * On each save: strips previously auto-generated divorced periods (those
 * starting at a married period's end_year), then re-inserts them with
 * the correct end_year. The end_year is the earliest of: the next period's
 * start_year, either partner's death_year, or null (ongoing).
 *
 * Finally, caps all periods at the earliest death year of either partner.
 */
export function withAutoDissolvedPeriods(
  periods: RelationshipPeriod[],
  partnerDeathYears?: { source?: number | null; target?: number | null },
): RelationshipPeriod[] {
  const sorted = [...periods].sort((a, b) => a.start_year - b.start_year);
  const cleaned = stripAutoGeneratedDivorces(sorted);
  const earliestDeath = computeEarliestDeath(partnerDeathYears);

  const result: RelationshipPeriod[] = [];
  for (let i = 0; i < cleaned.length; i++) {
    const period = cleaned[i];
    result.push(period);

    if (period.status !== PartnerStatus.Married || period.end_year == null) continue;
    const next = cleaned[i + 1];
    if (next && next.start_year <= period.end_year) continue;

    result.push({
      start_year: period.end_year,
      end_year: computeDivorceEndYear(period.end_year, next, earliestDeath),
      status: PartnerStatus.Divorced,
    });
  }

  return capPeriodsAtDeath(result, partnerDeathYears);
}

export interface Person {
  name: string;
  birth_year: number | null;
  birth_month: number | null;
  birth_day: number | null;
  death_year: number | null;
  death_month: number | null;
  death_day: number | null;
  gender: string;
  is_adopted: boolean;
  notes: string | null;
  position?: { x: number; y: number };
}

export interface RelationshipData {
  type: RelationshipType;
  periods: RelationshipPeriod[];
  active_period: { start_year: number; end_year: number | null } | null;
}

export interface TraumaEvent {
  title: string;
  description: string;
  category: TraumaCategory;
  approximate_date: string;
  severity: number;
  tags: string[];
}

export enum LifeEventCategory {
  Family = "family",
  Education = "education",
  Career = "career",
  Relocation = "relocation",
  Health = "health",
  Medication = "medication",
  Other = "other",
}

export interface LifeEvent {
  title: string;
  description: string;
  category: LifeEventCategory;
  approximate_date: string;
  impact: number | null;
  tags: string[];
}

export type ClassificationStatus = "suspected" | "diagnosed";

export interface ClassificationPeriod {
  start_year: number;
  end_year: number | null;
}

export interface Classification {
  dsm_category: string;
  dsm_subcategory: string | null;
  status: ClassificationStatus;
  diagnosis_year: number | null;
  periods: ClassificationPeriod[];
  notes: string | null;
}

export interface LinkedEntity {
  entity_type: "trauma_event" | "life_event" | "classification";
  entity_id: string;
}

export interface Pattern {
  name: string;
  description: string;
  color: string;
  linked_entities: LinkedEntity[];
}

export interface EncryptedBlob {
  iv: string;
  ciphertext: string;
}
